min(test,na.rm=T)
test<-heartattack[1:40]
min(test,na.rm=T)
test==min(test,na.rm=T)
name<-outcome[1:40,2]
head(name)
name(test==min(test,na.rm=T))
name[test==min(test,na.rm=T)]
notna<-!is.na(test)
name[notna][test[notna]==min(test,na.rm=T)]
state<-outcome$State[1:40]
state
test[state=="AL"]
test[state=="MD"]
a<-c(T,F,T,F)
b<-c(T,T,F,F)
a & b
a | b
sort(c("m","b","g","d"))
v<-c("m","b","g","d")
sort(v)
v
sort(v)[1]
source("best.R")
best("TX", "heart attack")
best("TX", "heart failure")
best("MD", "heart attack")
best("MD", "pneumonia")
best("BB", "heart attack")
best("NY", "hert attack")
v<-c(1:10)
v[1]
v[-1]
v[10]
(ii <- order(x <- c(1,1,3:1,1:4,3), y <- c(9,9:1), z <- c(2,1:9)))
dd <- transform(data.frame(x, y, z),
z = factor(z, labels = LETTERS[9:1]))
dd
order(dd)
dd[ order(x, -y, z), ]
dd[ order(x, z), ]
dd[ order(x, y), ]
outcomedata <- read.csv("outcome-of-care-measures.csv", colClasses = "character")
index<-17
state<-"TX"
outcomedata[, index] <- as.numeric(outcomedata[, index])
outcomedata<-outcomedata[(outcomedata$State==state)&(!is.na(outcomedata[, index])),]
head(outcomedata[order(outcomedata[, index],outcomedata[, 2]),])
head(outcomedata[order(outcomedata[, index],outcomedata[, 2]),c(2,index)])
z
z[length(z)]
a<-NA
a
source("rankhospital.R")
rankhospital("TX", "heart failure", 4)
rankhospital("MD", "heart attack", "worst")
rankhospital("MN", "heart attack", 5000)
is.numeric(3)
is.numeric(c(3,5))
source("rankhospital.R")
rankhospital("TX", "heart failure", 4)
rankhospital("MD", "heart attack", "worst")
rankhospital("MN", "heart attack", 5000)
outcomedata <- read.csv("outcome-of-care-measures.csv", colClasses = "character")
outcomedata[,index]<-as.numeric(outcomedata[,index])
index<-17
outcomedata[,index]<-as.numeric(outcomedata[,index])
state<-"TX"
bestall<-outcomedata[(outcomedata$State==state)&(!is.na(outcomedata[,index])),c(index,2)]
head(bestall)
head(bestall[1])
head(bestall[2])
bestall[order(bestall),1:6]
head(bestall[order(bestall),])
(ii <- order(x <- c(1,1,3:1,1:4,3), y <- c(9,9:1), z <- c(2,1:9)))
rbind(x, y, z)[,ii]
head(bestall[order(bestall[1],bestall[2]),])
dd <- data.frame(x, y, z)
dd
dd[order(dd),]
order(dd)
order(dd[1],dd[2],dd[3])
dd[do.call(order,dd),]
dd[order(dd[1],dd[2],dd[3])]
dd[order(dd[1],dd[2],dd[3]),]
bestall<-outcomedata[(outcomedata$State==state)&(!is.na(outcomedata[,index])),c(2,index)]
head(bestall)
head(bestall[order(bestall[,2],bestall[,1]),])
a<-character()
a
a<-c(a,"x")
a
a<-c(a,"NA")
a
a<-c(a,"<NA>")
a
head(bestall)
bestall<-bestall[order(bestall[,2],bestall[,1]),]
head(bestall)
x
y
data.frame(x,y)
a<-data.frame(x,y)
class(a)
source("rankall.R")
head(rankall("heart attack", 20), 10)
numeric(2)
makeCacheMatrix <- function(x = matrix()) {
+
+}
+
+
+# holds the cached value or NULL if nothing is cached
+# initially nothing is cached so set it to NULL
+cache <- NULL
+# store a matrix
+setMatrix <- function(newValue) {
+ x <<- newValue
+ # since the matrix is assigned a new value, flush the cache
+ cache <<- NULL
+}
+# returns the stored matrix
+getMatrix <- function() {
+ x
}
+# cache the given argument
+cacheInverse <- function(solve) {
+ cache <<- solve
+}
-## Write a short comment describing this function
+# get the cached value
+getInverse <- function() {
+ cache
+}
-cacheSolve <- function(x, ...) {
- ## Return a matrix that is the inverse of 'x'
+# return a list. Each named element of the list is a function
+list(setMatrix = setMatrix, getMatrix = getMatrix, cacheInverse = cacheInverse, getInverse = getInverse)
}
+
+
+# The following function calculates the inverse of a "special" matrix created with
+# makeCacheMatrix
+
+cacheSolve <- function(y, ...) {
+ # get the cached value
+ inverse <- y$getInverse()
+ # if a cached value exists return it
+ if(!is.null(inverse)) {
+ message("getting cached data")
+ return(inverse)
+ }
+ # otherwise get the matrix, caclulate the inverse and store it in
+ # the cache
+ data <- y$getMatrix()
+ inverse <- solve(data)
+ y$cacheInverse(inverse)
+
+ # return the inverse
+ inverse
+}
makeCacheMatrix <- function(x = matrix()) {
cache <- NULL
setMatrix <- function(newValue) {
x <<- newValue
cache <<- NULL
}
getMatrix <- function() {
x
}
cacheInverse <- function(solve) {
cache <<- solve
}
getInverse <- function() {
cache
}
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
# return a list. Each named element of the list is a function
list(setMatrix = setMatrix, getMatrix = getMatrix, cacheInverse = cacheInverse, getInverse = getInverse)
}
cacheSolve <- function(y, ...) {
inverse <- y$getInverse()
# if a cached value exists return it
if(!is.null(inverse)) {
message("getting cached data")
return(inverse)
}
# otherwise get the matrix, caclulate the inverse and store it in
# the cache
data <- y$getMatrix()
inverse <- solve(data)
y$cacheInverse(inverse)
# return the inverse
inverse
}
}
makeCacheMatrix <- function(x = matrix()) {
}
cache <- NULL
setMatrix <- function(newValue) {
x <<- newValue
cache <<- NULL
}
getMatrix <- function() {
x
}
cacheInverse <- function(solve) {
cache <<- solve
}
getInverse <- function() {
cache
}
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
# return a list. Each named element of the list is a function
list(setMatrix = setMatrix, getMatrix = getMatrix, cacheInverse = cacheInverse, getInverse = getInverse)
}
cacheSolve <- function(y, ...) {
inverse <- y$getInverse()
# if a cached value exists return it
if(!is.null(inverse)) {
message("getting cached data")
return(inverse)
}
# otherwise get the matrix, caclulate the inverse and store it in
# the cache
data <- y$getMatrix()
inverse <- solve(data)
y$cacheInverse(inverse)
# return the inverse
inverse
}
x<-matrix(1:4,2,2)
mat<-makeCacheMatrix(x)
cacheSolve(mat)
debug cacheSolve
debug(cacheSolve)
cacheSolve(mat)
# makeCacheMatrix is a function that returns a list of functions
# Its puspose is to store a martix and a cached value of the inverse of the
# matrix. Contains the following functions:
# * setMatrix set the value of a matrix
# * getMatrix get the value of a matrix
# * cacheInverse get the cahced value (inverse of the matrix)
# * getInverse get the cahced value (inverse of the matrix)
makeCacheMatrix <- function(x = matrix()) {
# holds the cached value or NULL if nothing is cached
# initially nothing is cached so set it to NULL
cache <- NULL
# store a matrix
setMatrix <- function(newValue) {
x <<- newValue
# since the matrix is assigned a new value, flush the cache
cache <<- NULL
}
# returns the stored matrix
getMatrix <- function() {
x
}
# cache the given argument
cacheInverse <- function(solve) {
cache <<- solve
}
# get the cached value
getInverse <- function() {
cache
}
# return a list. Each named element of the list is a function
list(setMatrix = setMatrix, getMatrix = getMatrix, cacheInverse = cacheInverse, getInverse = getInverse)
}
# The following function calculates the inverse of a "special" matrix created with
# makeCacheMatrix
cacheSolve <- function(y, ...) {
# get the cached value
inverse <- y$getInverse()
# if a cached value exists return it
if(!is.null(inverse)) {
message("getting cached data")
return(inverse)
}
# otherwise get the matrix, caclulate the inverse and store it in
# the cache
data <- y$getMatrix()
inverse <- solve(data)
y$cacheInverse(inverse)
# return the inverse
inverse
}
x<-matrix(1:4,2,2)
mat<-makeCacheMatrix(x)
cacheSolve(mat)
solve(x)
y<-cbind(1:3,c(2,3,2),3:1)
maty<-makeCacheMatrix(y)
cacheSolve(maty)
solve(y)
cacheSolve(mat)
cacheSolve(maty)
## Put comments here that give an overall description of what your
## functions do
## Write a short comment describing this function
makeCacheMatrix <- function(x = matrix()) {
m <- NULL
set <- function(y)
{
x <<-y
m <<- NULL
}
get <- function() x
setmatrix <- function(solve) m <<- solve
getmatrix <- function() m
list(set = set, get = get, setmatrix = setmatrix, getmatrix = getmatrix)
}
## Write a short comment describing this function
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
m <- x$getmatrix()
if(!is.null(m))
{
message("getting cached matrix")
return(m)
}
data <- x$get()
# Matric Algebra
#http://www.statmethods.net/advstats/matrix.html
#solve(A) inverse of A where A is a square matrix
m <- solve(data,...)
x$setmatrix(m)
m
}
x<-matrix(1:4,2,2)
mat<-makeCacheMatrix(x)
cacheSolve(mat)
solve(x)
y<-cbind(1:3,c(2,3,2),3:1)
maty<-makeCacheMatrix(y)
cacheSolve(maty)
solve(y)
cacheSolve(mat)
cacheSolve(maty)
# Calculates the inverse of a matrix and stores it in the cache
# Aaron I. Velez Ramirez
#
#####
# The first function, makeCacheMatrix, creates a list of functions that get the original and
# inverted matrices ('get' and 'getinvert', respectiveley), and caches the original and inverted matrix
# ('set' and 'setinvert'). It takes an invertible matrix as input.
makeCacheMatrix <- function(x = matrix()) {
mx <- NULL # Creates an empty object to cache the inverted matrix when calculated
set <- function(y) { # Replaces old matrix with new one AND deletes old inverted matrix
x <<- y
mx <<- NULL
}
get <- function() x # Gets the original matrrix
setinvert <- function(inv.matrix) # Stores the inverted matrix it in the cache
mx <<- inv.matrix
getinvert <- function() mx # Gets the inverted matrix stored in the cache
list(set=set, get=get, setinvert=setinvert, # Returns all functions as a list
getinverto=getinvert)
}
#####
# The second function, cacheSolve, calculates the inverse of a matrix stored in 'x'. If the inverse
# has been already calculated and the matrix is identical to the "target" matrix 'y', it retrieves
# the cached inverted matrix stored in x. When needed, it calls functions stored in object 'x'.
cacheSolve <- function(x, y, ...) {
change <- NULL
if (!identical(x$get(), y)) { # Test if the matrix has changed
x$set(y) # If TRUE Sets the new matrix in x
change <- TRUE
message("Matrix has changed, replacing cache data")
} else {
change <- FALSE
}
mx <- x$getinvert() # Gets the inverted cached matrix
if (!is.null(mx) && !change) { # Test if the matrix has been already inverted and cached
message("Getting cached data")
return(mx)
}
message("Caching data")
data <- x$get() # Calls the original matrix
mx <- solve(data) # Return a matrix that is the inverse of 'x'
x$setinvert(mx) # Calls the 'setinvert' function to cache the new inverted matrix
mx # Prints the inverted matrix
}
x<-matrix(1:4,2,2)
mat<-makeCacheMatrix(x)
cacheSolve(mat)
cacheSolve(mat,x)
solve(x)
y<-cbind(1:3,c(2,3,2),3:1)
maty<-makeCacheMatrix(y)
cacheSolve(maty,x)
cacheSolve(maty,y)
solve(y)
cacheSolve(mat)
cacheSolve(mat,x)
cacheSolve(maty,y)
cacheSolve(maty,y)
cacheSolve(maty,x)
## Put comments here that give an overall description of what your
## functions do
## Write a short comment describing this function
makeCacheMatrix <- function(x = matrix()) {
# holds the cached value or NULL if nothing is cached
# initially nothing is cached so set it to NULL
cache <- NULL
# store a matrix
setMatrix <- function(newValue) {
x <<- newValue
# since the matrix is assigned a new value, flush the cache
cache <<- NULL
}
# returns the stored matrix
getMatrix <- function() {
x
}
# cache the given argument
cacheInverse <- function(solve) {
cache <<- solve
}
# get the cached value
getInverse <- function() {
cache
}
# return a list. Each named element of the list is a function
list(setMatrix = setMatrix, getMatrix = getMatrix, cacheInverse = cacheInverse, getInverse = getInverse)
}
## Write a short comment describing this function
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
# get the cached value
inverse <- y$getInverse()
# if a cached value exists return it
if(!is.null(inverse)) {
message("getting cached data")
return(inverse)
}
# otherwise get the matrix, caclulate the inverse and store it in
# the cache
data <- y$getMatrix()
inverse <- solve(data)
y$cacheInverse(inverse)
# return the inverse
inverse
}
x<-matrix(1:4,2,2)
mat<-makeCacheMatrix(x)
cacheSolve(mat)
## Put comments here that give an overall description of what your
## functions do
## Write a short comment describing this function
makeCacheMatrix <- function(x = matrix()) {
# holds the cached value or NULL if nothing is cached
# initially nothing is cached so set it to NULL
cache <- NULL
# store a matrix
setMatrix <- function(newValue) {
x <<- newValue
# since the matrix is assigned a new value, flush the cache
cache <<- NULL
}
# returns the stored matrix
getMatrix <- function() {
x
}
# cache the given argument
cacheInverse <- function(solve) {
cache <<- solve
}
# get the cached value
getInverse <- function() {
cache
}
# return a list. Each named element of the list is a function
list(setMatrix = setMatrix, getMatrix = getMatrix, cacheInverse = cacheInverse, getInverse = getInverse)
}
## Write a short comment describing this function
cacheSolve <- function(y, ...) {
## Return a matrix that is the inverse of 'x'
# get the cached value
inverse <- y$getInverse()
# if a cached value exists return it
if(!is.null(inverse)) {
message("getting cached data")
return(inverse)
}
# otherwise get the matrix, caclulate the inverse and store it in
# the cache
data <- y$getMatrix()
inverse <- solve(data)
y$cacheInverse(inverse)
# return the inverse
inverse
}
cacheSolve(mat)
solve(x)
y<-cbind(1:3,c(2,3,2),3:1)
maty<-makeCacheMatrix(y)
cacheSolve(maty)
solve(y)
cacheSolve(mat)
cacheSolve(maty)
?opts_chunk$set
opts_chunk$set
library(knitr)
?opts_chunk$set
?opts_chunk
getwd()
setwd("C:\\Users\\Wei\\Documents\\Git\\RepData_PeerAssessment1")
pwd()
getwd()
